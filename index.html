<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Angry LED Eyes - Camera Tracking</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000000;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
    }

    #video {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 160px;
      height: 120px;
      border: 2px solid #ff0000;
      display: none;
    }
  </style>
</head>

<body>
  <video id="video" autoplay playsinline></video>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7"></script>

  <script type="module">
    import * as THREE from "https://esm.sh/three@0.161";
    import { OrbitControls } from "https://esm.sh/three@0.161/examples/jsm/controls/OrbitControls.js";

    /**
     * Configuration Constants
     * Single Responsibility: Centralized configuration management
     */
    const CONFIG = {
      CAMERA: {
        FOV: 50,
        NEAR: 0.1,
        FAR: 1000,
        POSITION_Z: 6,
        POSITION_Z_MOBILE: 8
      },
      VIDEO: {
        WIDTH: 640,
        HEIGHT: 480,
        FACING_MODE: 'user' // Front camera for mobile
      },
      EYE: {
        SPACING: 2.8,
        SPACING_MOBILE: 2.0,
        COLORS: {
          PRIMARY: 0xff0000,
          INNER_GLOW: 0xff3333,
          OUTER_GLOW: 0xff1111
        },
        OUTLINE_OPACITY: 0.3,
        BROW_OPACITY: 0.8
      },
      DEVICE: {
        IS_MOBILE: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
        TOUCH_ENABLED: 'ontouchstart' in window || navigator.maxTouchPoints > 0
      },
      PUPIL: {
        RADIUS: 0.25,
        INNER_GLOW_RADIUS: 0.4,
        OUTER_GLOW_RADIUS: 0.6,
        INNER_GLOW_OPACITY: 0.7,
        OUTER_GLOW_OPACITY: 0.4,
        MAX_MOVEMENT_X: 1.2,
        MAX_MOVEMENT_Y: 0.15
      },
      ANIMATION: {
        PUPIL_SMOOTHING: 0.1,
        BROW_SMOOTHING: 0.08,
        PULSE_SPEED: 3,
        PULSE_MIN: 0.8,
        PULSE_AMPLITUDE: 0.2,
        FACE_MULTIPLIER_X: 1.2,
        FACE_MULTIPLIER_Y: 0.2,
        BROW_RELAXED_Y: 0.4,
        BROW_FOCUSED_Y: 0
      }
    };

    /**
     * Utility Functions
     * DRY Principle: Reusable helper functions
     */
    class MathUtils {
      static clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      static lerp(start, end, factor) {
        return start + (end - start) * factor;
      }

      static normalizeCoordinate(value, max) {
        return (value / max) * 2 - 1;
      }
    }

    /**
     * Material Factory
     * Single Responsibility: Creates and manages materials
     */
    class MaterialFactory {
      static createBasicMaterial(color, opacity, additiveBlending = false) {
        return new THREE.MeshBasicMaterial({
          color,
          transparent: true,
          opacity,
          ...(additiveBlending && { blending: THREE.AdditiveBlending })
        });
      }

      static createEyeOutlineMaterial() {
        return this.createBasicMaterial(
          CONFIG.EYE.COLORS.PRIMARY,
          CONFIG.EYE.OUTLINE_OPACITY
        );
      }

      static createPupilMaterial() {
        return this.createBasicMaterial(CONFIG.EYE.COLORS.PRIMARY, 1);
      }

      static createInnerGlowMaterial() {
        return this.createBasicMaterial(
          CONFIG.EYE.COLORS.INNER_GLOW,
          CONFIG.PUPIL.INNER_GLOW_OPACITY,
          true
        );
      }

      static createOuterGlowMaterial() {
        return this.createBasicMaterial(
          CONFIG.EYE.COLORS.OUTER_GLOW,
          CONFIG.PUPIL.OUTER_GLOW_OPACITY,
          true
        );
      }

      static createBrowMaterial() {
        return this.createBasicMaterial(
          CONFIG.EYE.COLORS.PRIMARY,
          CONFIG.EYE.BROW_OPACITY
        );
      }
    }

    /**
     * Shape Factory
     * Single Responsibility: Creates geometric shapes
     */
    class ShapeFactory {
      static createEyeOutlineShape(isLeft) {
        const shape = new THREE.Shape();
        const angle = isLeft ? 0.25 : -0.25;

        shape.moveTo(-2.5, angle);
        shape.quadraticCurveTo(-1.5, 0.4 + angle, 0, 0.3);
        shape.quadraticCurveTo(1.5, 0.4 - angle, 2.5, -angle);
        shape.quadraticCurveTo(1.5, -0.2 - angle, 0, -0.15);
        shape.quadraticCurveTo(-1.5, -0.2 + angle, -2.5, angle);

        return shape;
      }

      static createBrowShape(isLeft) {
        const shape = new THREE.Shape();
        const angle = isLeft ? 0.3 : -0.3;

        shape.moveTo(-2.7, 0.7 + angle);
        shape.quadraticCurveTo(0, 0.9, 2.7, 0.7 - angle);
        shape.lineTo(2.5, 0.85 - angle);
        shape.quadraticCurveTo(0, 1.05, -2.5, 0.85 + angle);

        return shape;
      }
    }

    /**
     * Eye Component Builder
     * Single Responsibility: Builds eye components
     */
    class EyeComponentBuilder {
      static createPupilGroup() {
        const group = new THREE.Group();

        const pupil = this.createPupil();
        const innerGlow = this.createInnerGlow();
        const outerGlow = this.createOuterGlow();

        group.add(pupil, innerGlow, outerGlow);
        return group;
      }

      static createPupil() {
        const geometry = new THREE.CircleGeometry(CONFIG.PUPIL.RADIUS, 32);
        const material = MaterialFactory.createPupilMaterial();
        return new THREE.Mesh(geometry, material);
      }

      static createInnerGlow() {
        const geometry = new THREE.CircleGeometry(CONFIG.PUPIL.INNER_GLOW_RADIUS, 32);
        const material = MaterialFactory.createInnerGlowMaterial();
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.z = -0.01;
        return mesh;
      }

      static createOuterGlow() {
        const geometry = new THREE.CircleGeometry(CONFIG.PUPIL.OUTER_GLOW_RADIUS, 32);
        const material = MaterialFactory.createOuterGlowMaterial();
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.z = -0.02;
        return mesh;
      }

      static createEyeOutline(isLeft) {
        const shape = ShapeFactory.createEyeOutlineShape(isLeft);
        const geometry = new THREE.ShapeGeometry(shape);
        const material = MaterialFactory.createEyeOutlineMaterial();
        return new THREE.Mesh(geometry, material);
      }

      static createBrow(isLeft) {
        const shape = ShapeFactory.createBrowShape(isLeft);
        const geometry = new THREE.ShapeGeometry(shape);
        const material = MaterialFactory.createBrowMaterial();
        return new THREE.Mesh(geometry, material);
      }
    }

    /**
     * Eye Entity
     * Single Responsibility: Represents a complete eye with its components
     */
    class Eye {
      constructor(isLeft) {
        this.isLeft = isLeft;
        this.group = new THREE.Group();
        this.pupilGroup = null;
        this.browMesh = null;
        
        this.build();
      }

      build() {
        const outline = EyeComponentBuilder.createEyeOutline(this.isLeft);
        this.pupilGroup = EyeComponentBuilder.createPupilGroup();
        this.browMesh = EyeComponentBuilder.createBrow(this.isLeft);

        this.group.add(outline, this.pupilGroup, this.browMesh);
        this.group.userData.pupil = this.pupilGroup;
        this.group.userData.brow = this.browMesh;
        this.group.userData.isLeft = this.isLeft;
      }

      getGroup() {
        return this.group;
      }

      setScale(scale) {
        this.group.scale.set(scale, scale, scale);
      }

      setPupilPosition(x, y) {
        this.pupilGroup.position.set(x, y, 0);
      }

      setBrowPosition(y) {
        this.browMesh.position.y = y;
      }

      setPulseOpacity(innerOpacity, outerOpacity) {
        this.pupilGroup.children[1].material.opacity = innerOpacity;
        this.pupilGroup.children[2].material.opacity = outerOpacity;
      }
    }

    /**
     * Face Tracker
     * Single Responsibility: Manages face detection and tracking
     */
    class FaceTracker {
      constructor(videoElement) {
        this.videoElement = videoElement;
        this.model = null;
        this.facePosition = { x: 0, y: 0 };
        this.isDetected = false;
        this.previousDetectionState = false;
      }

      async initialize() {
        await this.setupCamera();
        this.model = await blazeface.load();
      }

      async setupCamera() {
        try {
          const constraints = {
            video: {
              width: { ideal: CONFIG.VIDEO.WIDTH },
              height: { ideal: CONFIG.VIDEO.HEIGHT },
              facingMode: CONFIG.VIDEO.FACING_MODE
            }
          };

          // Try with ideal constraints first
          let stream;
          try {
            stream = await navigator.mediaDevices.getUserMedia(constraints);
          } catch (err) {
            // Fallback for older mobile devices
            console.warn('Failed with ideal constraints, trying basic video');
            stream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: CONFIG.VIDEO.FACING_MODE }
            });
          }

          this.videoElement.srcObject = stream;

          return new Promise((resolve) => {
            this.videoElement.onloadedmetadata = () => resolve();
          });
        } catch (error) {
          console.error('Camera setup failed:', error);
          throw new Error('Unable to access camera. Please grant camera permissions.');
        }
      }

      async detectFace() {
        if (!this.model) return;

        const predictions = await this.model.estimateFaces(this.videoElement, false);
        this.previousDetectionState = this.isDetected;

        if (predictions.length > 0) {
          this.isDetected = true;
          this.updateFacePosition(predictions[0]);
        } else {
          this.isDetected = false;
        }

        requestAnimationFrame(() => this.detectFace());
      }

      updateFacePosition(face) {
        const centerX = (face.topLeft[0] + face.bottomRight[0]) / 2;
        const centerY = (face.topLeft[1] + face.bottomRight[1]) / 2;

        this.facePosition.x = -MathUtils.normalizeCoordinate(centerX, this.videoElement.videoWidth);
        this.facePosition.y = -MathUtils.normalizeCoordinate(centerY, this.videoElement.videoHeight);
      }

      getFacePosition() {
        return { ...this.facePosition };
      }

      isFaceDetected() {
        return this.isDetected;
      }

      hasDetectionStateChanged() {
        return this.isDetected !== this.previousDetectionState;
      }

      startTracking() {
        this.detectFace();
      }
    }

    /**
     * Animation Controller
     * Single Responsibility: Manages animation state and updates
     */
    class AnimationController {
      constructor(leftEye, rightEye, faceTracker) {
        this.leftEye = leftEye;
        this.rightEye = rightEye;
        this.faceTracker = faceTracker;
        
        this.time = 0;
        this.currentPupilPosition = { x: 0, y: 0 };
        this.currentBrowY = 0;
        this.targetBrowY = 0;
      }

      update() {
        this.time += 0.01;

        if (this.faceTracker.hasDetectionStateChanged()) {
          this.targetBrowY = this.faceTracker.isFaceDetected()
            ? CONFIG.ANIMATION.BROW_FOCUSED_Y
            : CONFIG.ANIMATION.BROW_RELAXED_Y;
        }

        this.updatePupilPosition();
        this.updateBrowPosition();
        this.updatePulseEffect();
      }

      updatePupilPosition() {
        const facePosition = this.faceTracker.getFacePosition();
        const isDetected = this.faceTracker.isFaceDetected();

        const targetX = isDetected ? facePosition.x * CONFIG.ANIMATION.FACE_MULTIPLIER_X : 0;
        const targetY = isDetected ? facePosition.y * CONFIG.ANIMATION.FACE_MULTIPLIER_Y : 0;

        this.currentPupilPosition.x = MathUtils.lerp(
          this.currentPupilPosition.x,
          targetX,
          CONFIG.ANIMATION.PUPIL_SMOOTHING
        );
        this.currentPupilPosition.y = MathUtils.lerp(
          this.currentPupilPosition.y,
          targetY,
          CONFIG.ANIMATION.PUPIL_SMOOTHING
        );

        const clampedX = MathUtils.clamp(
          this.currentPupilPosition.x,
          -CONFIG.PUPIL.MAX_MOVEMENT_X,
          CONFIG.PUPIL.MAX_MOVEMENT_X
        );
        const clampedY = MathUtils.clamp(
          this.currentPupilPosition.y,
          -CONFIG.PUPIL.MAX_MOVEMENT_Y,
          CONFIG.PUPIL.MAX_MOVEMENT_Y
        );

        this.leftEye.setPupilPosition(clampedX, clampedY);
        this.rightEye.setPupilPosition(clampedX, clampedY);
      }

      updateBrowPosition() {
        this.currentBrowY = MathUtils.lerp(
          this.currentBrowY,
          this.targetBrowY,
          CONFIG.ANIMATION.BROW_SMOOTHING
        );

        this.leftEye.setBrowPosition(this.currentBrowY);
        this.rightEye.setBrowPosition(this.currentBrowY);
      }

      updatePulseEffect() {
        const pulse = CONFIG.ANIMATION.PULSE_MIN + 
          Math.sin(this.time * CONFIG.ANIMATION.PULSE_SPEED) * CONFIG.ANIMATION.PULSE_AMPLITUDE;

        const innerOpacity = CONFIG.PUPIL.INNER_GLOW_OPACITY * pulse;
        const outerOpacity = CONFIG.PUPIL.OUTER_GLOW_OPACITY * pulse;

        this.leftEye.setPulseOpacity(innerOpacity, outerOpacity);
        this.rightEye.setPulseOpacity(innerOpacity, outerOpacity);
      }
    }

    /**
     * Scene Manager
     * Single Responsibility: Manages Three.js scene setup and rendering
     */
    class SceneManager {
      constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.onResizeCallback = null;
        
        this.initialize();
      }

      initialize() {
        this.createScene();
        this.createCamera();
        this.createRenderer();
        this.createControls();
        this.setupEventListeners();
      }

      createScene() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000000);
      }

      createCamera() {
        this.camera = new THREE.PerspectiveCamera(
          CONFIG.CAMERA.FOV,
          window.innerWidth / window.innerHeight,
          CONFIG.CAMERA.NEAR,
          CONFIG.CAMERA.FAR
        );
        // Adjust camera position based on device
        const cameraZ = CONFIG.DEVICE.IS_MOBILE ? CONFIG.CAMERA.POSITION_Z_MOBILE : CONFIG.CAMERA.POSITION_Z;
        this.camera.position.z = cameraZ;
      }

      createRenderer() {
        this.renderer = new THREE.WebGLRenderer({ 
          antialias: !CONFIG.DEVICE.IS_MOBILE, // Disable antialiasing on mobile for performance
          powerPreference: 'high-performance'
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(this.renderer.domElement);
      }

      createControls() {
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableZoom = false;
        this.controls.enableRotate = !CONFIG.DEVICE.IS_MOBILE; // Disable rotation on mobile
        this.controls.enablePan = false;
      }

      setupEventListeners() {
        window.addEventListener('resize', () => this.handleResize());
      }

      setResizeCallback(callback) {
        this.onResizeCallback = callback;
      }

      handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Optimize for mobile
        
        if (this.onResizeCallback) {
          this.onResizeCallback();
        }
      }

      addToScene(object) {
        this.scene.add(object);
      }

      render() {
        this.renderer.render(this.scene, this.camera);
      }
    }

    /**
     * Application
     * Single Responsibility: Main application orchestration
     */
    class Application {
      constructor() {
        this.sceneManager = new SceneManager();
        this.leftEye = null;
        this.rightEye = null;
        this.faceTracker = null;
        this.animationController = null;
      }

      async initialize() {
        this.createEyes();
        this.updateEyeLayout();
        this.sceneManager.setResizeCallback(() => this.updateEyeLayout());
        await this.setupFaceTracking();
        this.createAnimationController();
        this.start();
      }

      createEyes() {
        this.leftEye = new Eye(true);
        this.rightEye = new Eye(false);

        this.sceneManager.addToScene(this.leftEye.getGroup());
        this.sceneManager.addToScene(this.rightEye.getGroup());
      }

      updateEyeLayout() {
        const aspect = window.innerWidth / window.innerHeight;
        const width = window.innerWidth;
        const height = window.innerHeight;
        const isMobile = CONFIG.DEVICE.IS_MOBILE || aspect < 1;
        
        // Calculate responsive scale based on screen size
        let scale = 1.0;
        let spacing = CONFIG.EYE.SPACING;
        
        if (isMobile || aspect < 1.5) {
          // For mobile and narrow screens
          if (aspect < 0.5) {
            // Very narrow screens (portrait phones)
            scale = 0.4;
            spacing = 1.3;
          } else if (aspect < 0.7) {
            // Narrow portrait phones
            scale = 0.5;
            spacing = 1.5;
          } else if (aspect < 1) {
            // Portrait tablets or wider phones
            scale = 0.65;
            spacing = 1.8;
          } else if (aspect < 1.5) {
            // Landscape mobile or narrow desktop
            scale = 0.75;
            spacing = 2.2;
          }
        } else {
          // Desktop
          if (aspect < 1.8) {
            // Narrow desktop windows
            scale = 0.85;
            spacing = 2.5;
          } else {
            // Standard wide desktop
            scale = 1.0;
            spacing = 2.8;
          }
        }
        
        // Additional scaling based on absolute viewport size
        if (width < 500) {
          scale *= 0.7;
          spacing *= 0.8;
        } else if (width < 768) {
          scale *= 0.8;
          spacing *= 0.9;
        }
        
        // Apply scale to eyes
        this.leftEye.setScale(scale);
        this.rightEye.setScale(scale);
        
        // Apply spacing - center horizontally
        this.leftEye.getGroup().position.x = -spacing;
        this.rightEye.getGroup().position.x = spacing;
        
        // Center vertically
        this.leftEye.getGroup().position.y = 0;
        this.rightEye.getGroup().position.y = 0;
      }

      async setupFaceTracking() {
        const videoElement = document.getElementById('video');
        this.faceTracker = new FaceTracker(videoElement);
        await this.faceTracker.initialize();
        this.faceTracker.startTracking();
      }

      createAnimationController() {
        this.animationController = new AnimationController(
          this.leftEye,
          this.rightEye,
          this.faceTracker
        );
      }

      start() {
        this.animate();
      }

      animate() {
        requestAnimationFrame(() => this.animate());
        this.animationController.update();
        this.sceneManager.render();
      }
    }

    // Application Entry Point
    const app = new Application();
    app.initialize().catch(error => {
      console.error('Failed to initialize application:', error);
    });
  </script>
</body>
</html>
